import * as htmlparser2 from "htmlparser2";
import * as domutils from "domutils";
import * as domhandler from "domhandler";
import * as vscode from "vscode";
import * as fs from "fs/promises";
import * as path from "path";
import { exec } from "./utils";
import { workspaceState } from "./extension";

class MyFileCoverage extends vscode.FileCoverage {
  lineDetails: vscode.StatementCoverage[];

  constructor(
    detailedCoverage: vscode.StatementCoverage[],
    uri: vscode.Uri,
    statementCoverage: vscode.TestCoverageCount,
    branchCoverage?: vscode.TestCoverageCount,
    declarationCoverage?: vscode.TestCoverageCount,
  ) {
    super(uri, statementCoverage, branchCoverage, declarationCoverage);
    this.lineDetails = detailedCoverage;
  }
}

export async function loadDetailedCoverage(
  _testRun: vscode.TestRun,
  fileCoverage: vscode.FileCoverage,
  _token: vscode.CancellationToken,
): Promise<vscode.StatementCoverage[]> {
  return fileCoverage instanceof MyFileCoverage ? fileCoverage.lineDetails : [];
}

/**
 * Read coverage data generated during test execution.
 * @param buildDir Meson build directory
 * @returns `FileCoverage[]` to be added to be used with `run.addCoverage()`
 */
export async function getCoverage(buildDir: string): Promise<vscode.FileCoverage[]> {
  await exec("ninja", ["-C", buildDir, "coverage-xml"]);
  return parseXml(await fs.readFile(path.join(buildDir, "meson-logs", "coverage.xml"), "utf-8"));
}

/**
 * Parses a Cobertura xml file as generated by gcovr.
 * The schema is documented at
 * https://github.com/cobertura/cobertura/blob/master/cobertura/src/site/htdocs/xml/coverage-04.dtd
 * @param xml Contents of the Cobertura report
 * @returns `FileCoverage[]` to be added to be used with `run.addCoverage()`
 */
function parseXml(xml: string): vscode.FileCoverage[] {
  const ret: vscode.FileCoverage[] = [];

  const sourceDir = workspaceState.get<string>("mesonbuild.sourceDir")!;

  const dom = htmlparser2.parseDocument(xml, { xmlMode: true });
  const packages = domutils.findOne(
    (node) => {
      return node.name == "packages";
    },
    dom,
    true,
  )!;
  for (const pkg of packages.childNodes) {
    // The Cobertura format was designed for Java,
    // accordingly it considers classes the highest form of abstraction.
    // However, gcovr just creates one "class" per covered file, and fills it with line data.
    for (const cls of domutils.findOne((node) => node.name == "classes", pkg as domhandler.Element)!.childNodes) {
      const classElem = cls as domhandler.Element;
      const filePath = path.join(sourceDir, classElem.attribs["filename"]);
      const lineDetails: vscode.StatementCoverage[] = [];

      let coveredBranches = 0;
      let totalBranches = 0;
      let coveredLines = 0;
      let totalLines = 0;

      for (const line of domutils.findOne((node) => node.name == "lines", cls as domhandler.Element)!.childNodes) {
        totalLines++;
        const val = processLine(line as domhandler.Element);
        coveredLines += val.lineCovered ? 1 : 0;
        lineDetails.push(...val.lineDetails);
        coveredBranches += val.coveredBranches;
        totalBranches += val.totalBranches;
      }

      const lineData = new vscode.TestCoverageCount(coveredLines, totalLines);
      const branchData = new vscode.TestCoverageCount(coveredBranches, totalBranches);
      ret.push(new MyFileCoverage(lineDetails, vscode.Uri.file(filePath), lineData, branchData));
    }
  }
  return ret;
}

function processLine(line: domhandler.Element): {
  lineCovered: boolean;
  lineDetails: vscode.StatementCoverage[];
  coveredBranches: number;
  totalBranches: number;
} {
  const hits = parseInt(line.attribs["hits"]);
  const lineNo = parseInt(line.attribs["number"]);
  // Position is 0-indexed
  const position = new vscode.Position(lineNo - 1, 0);

  const lineCovered = hits > 0;
  const lineDetails: vscode.StatementCoverage[] = [];
  let coveredBranches = 0;
  let totalBranches = 0;

  if (line.attribs["branch"] == "true") {
    const val = processBranch(line, position);
    coveredBranches = val.coveredBranches;
    totalBranches = val.totalBranches;
    lineDetails.push(new vscode.StatementCoverage(hits, position, val.branchCoverage));
  } else {
    lineDetails.push(new vscode.StatementCoverage(hits, position));
  }

  return { lineCovered, lineDetails, coveredBranches, totalBranches };
}

function processBranch(
  line: domhandler.Element,
  position: vscode.Position,
): {
  branchCoverage: vscode.BranchCoverage[];
  coveredBranches: number;
  totalBranches: number;
} {
  const branchCoverage: vscode.BranchCoverage[] = [];
  // format is "50% (1/2)"
  const conditionStr = line.attribs["condition-coverage"];
  const match = RegExp(/\d+% \((\d+)\/(\d+)\)/).exec(conditionStr)!;

  const coveredBranches = parseInt(match[1]);
  const totalBranches = parseInt(match[2]);

  // The gcov report does not specify which branches were missed,
  // so the best we can do is report whether a branch site was
  // fully, partially, or not at all covered
  if (coveredBranches > 0) {
    branchCoverage.push(new vscode.BranchCoverage(true, position));
  }
  if (coveredBranches < totalBranches) {
    branchCoverage.push(new vscode.BranchCoverage(false, position));
  }
  return { branchCoverage, coveredBranches, totalBranches };
}
